# 作用域

所有的编程语言都可以存储变量的值，并且之后可以对变量进行访问，

那这些变量存储在哪里？怎么访问。我们需要一套规则来规定，这套规则就是作用域。



### 编译

代码在执行之前，通常要经过编译

编译器

 [https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067?fr=aladdin](https://baike.baidu.com/item/编译器/8853067?fr=aladdin) 

```javascript
var a = 1;   

// js 编译器会对var a=1; 编译，转行一条计算机可以识别的指令，然后做好执行他的准备，通常情况会立刻执行

// 1. 词法分析/分词  var a=1;  var ,a,=,1,;
// 2. 词法分析
// 3. 生成可以执行的代码（也就是指令）
```

 

- 引擎  
  - 从头到尾负责整个js程序的编译及执行过程
- 编译器
  - 和编译器配合，负责语法分析及代码生成等脏活累活

- 作用域
  - 和编译器配合，负责收集并维护由所有声明的标识符（变量）



### 变量赋值的流程

```javascript
var a =2，
分为2个阶段 var a 和 a=2;
```

1. 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。

   如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。

  2. 接下来编译器会为引擎生成运行时所需的代码。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量
  3. 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常！



### 变量的查找

#### lhs和rhs

在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。

lhs 通常是在=号的左边，包含读和写

rhs通常是在=号的右边，包含读

```java
console.log( a );
其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。
```

```javascript
a = 2;
这里对 a 的引用则是 LHS 引用，对变量赋值，对变量写的操作
```

```javascript
// demo 考虑下面的程序，其中既有 LHS 也有 RHS 引用
function foo(a)  {   
    console.log( a ); // 2
} 
foo( 2 );
foo 是rhs
a=2 是lhs
                  
```



总结：lhs 会查找并赋值（读和写的操作），rhs （只会执行读操作）



### 小测试

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”：

```javascript
function qq(a) {    
    var b = a;   
    return a + b;
} 
var c = qq( 2 );
```

1. 找到其中所有的 LHS 查询。（3 处！）
2.  找到其中所有的 RHS 查询。（4 处！）



### 作用域的嵌套

我们说过，作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。



规则：引擎先找自己的作用域，再一直往上找，找到就停止，找不到就报错。



```javascript
function foo(a) {    
    console.log( a + b );
} 
var b = 2; 
foo( 2 ); // 4
```

对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域（在这个例子中就 是全局作用域）中完成



把作用域链比喻成一个建筑

![mark](http://cdn.cs1024.com/images/20191129/NvEgh8KwyQtd.png?imageslim)



### 　异常

为什么区分 LHS 和 RHS 是一件重要的事情？

因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行 为是不一样的。

```javascript
console.log(b);
a=2;

```



对b进行的是rhs查询，读的操作，找不到，引擎直接报错

对a进行的是lhs查询，在非严格模式下，如果作用域链找不到，js引擎会自动帮忙创建a，并赋值undefined



# 词法作用域

```
词法作用域：函数在定义的时候决定了函数的作用域，JavaScript采用词法作用域。
动态作用域：函数在调用的时候决定函数的作用域，目前只有部分语言支持。
```



无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 

```javascript
function foo(a) {     
    var b = a * 2; 
    function bar(c) {   
        console.log( a, b, c );     
    } 
    bar( b * 3 ); 
} 
foo( 2 ); // 2, 4, 12
```

在这个例子中有三个逐级嵌套的作用域。

![mark](http://cdn.cs1024.com/images/20191129/ykRfCapRk726.png?imageslim)



### 查找

console.log(a1)查找的过程，先找1，再找2，再找3，再找全局作用域，都找不到，引擎报错。



#### 遮蔽效应

假如c函数里面有a1了，就不会再向上找了，上面就被屏蔽了。



#### 全局变量

全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。

```java
window.a
```



### eval 欺骗(选学,开发中不用)

```javascript
function foo(str, a) {  
    eval( str ); // 欺骗！    
    console.log( a, b ); 
}  
var b = 2; 
foo( "var b = 3;", 1 ); // 1, 3
```

eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实 上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽 了外部（全局）作用域中的同名变量。



当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到 外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。





# 函数作用域

作用域包含了一系列的“气泡”，每一个都可以作为容 器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成嵌套型，排列的结构是在写代码时定义的。

但是，究竟是什么生成了一个新的气泡？只有函数会生成新的气泡吗？ JavaScript 中的其 他结构能生成作用域气泡吗？



对于前面提出的问题，最常见的答案是 JavaScript 具有基于函数的作用域，意味着每声明 一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并 不完全正确，下面我们来看一下。

```javascript
function foo(a) { 
    var b = 2;
    // 一些代码 
    function bar() {      
        // ...  
    } 
    // 更多的代码  
    var c = 3; 
}
```

在这个代码片段中，foo(..) 的作用域气泡中包含了标识符 a、b、c 和 bar。无论标识符 声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡





由于标识符 a、b、c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部 对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的 代码会导致 ReferenceError 错误：

```javascript
bar(); // 失败 
console.log( a, b, c ); // 三个全都失败
```



但是，这些标识符（a、b、c、foo 和 bar）在 foo(..) 的内部都是可以被访问的，同样在 bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）。



### 对变量和函数隐藏

可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域 来“隐藏”它们。



有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来 的，也叫最小授权或最小暴露原则

如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，

```javascript
function doSomething(a) {   
    b = a + doSomethingElse( a * 2 );  
    console.log( b * 3 ); 
} 
 
function doSomethingElse(a) {   
    return a - 1; 
} 
 
var b;  
doSomething( 2 ); // 15
```

在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体 实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅 没有必要，而且可能是“危险”的，



因为它们可能被有意或无意地以非预期的方式使用， 从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内 容隐藏在 doSomething(..) 内部，例如：

```javascript
function doSomething(a) {    
    function doSomethingElse(a) { 
        return a - 1; 
    } 
    var b; 
    b = a + doSomethingElse( a * 2 ); 
    console.log( b * 3 );
}  
doSomething( 2 ); // 15

```

现在，b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。 功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会 依此进行实现



### 规避冲突

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，

```javascript
function foo() {  
    function bar(a) {    
        i = 3; // 修改 for 循环所属作用域中的 i       
        console.log( a + i ); 
    } 
 
    for (var i=0; i<10; i++) {  
        bar( i * 2 ); // 糟糕，无限循环了！     
    } 
}  
foo();
```

bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这 个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。



### 全局命名空间 

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突



```javascript
var q=1;

// 类库1
function f1() {
    q=2;
}

// 类库2
function f2() {
    q=3;
}
```

q 会被全局污染



正确做法

```javascript
var q=1;

// 类库1
function f1() {
    var m =q;
    m=2;
}

// 类库2
function f2() {
    var n=q;
    n=3;
}
```



### 函数名污染全局作用域

```javascript
var a = 2; 
 
function foo() { // <-- 添加这一行 
 
    var a = 3;    
    console.log( a ); // 3 
 
} // <-- 以及这一行 foo(); // <-- 以及这一行 
 
console.log( a ); // 2
```

首先， 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域（在这个 例子中是全局作用域）。



其次，必须显式地通过函数名（foo()）调用这个函数才能运行其 中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行， 这将会更加理想。

解决方法

```javascript
(function foo() { // <-- 添加这一行 
 
    var a = 3;    
    console.log( a ); // 3 
 
}）();
```

函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不 是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一 个标准的函数声明来处理。



#### 函数声明和函数表达式

区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式



##### 区别

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处



比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。



### 匿名与具名

```javascript
setTimeout(
    function() {    
        console.log("I waited 1 second!"); 
    }, 1000 );
```

这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的， 而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

```javascript
setTimeout( function timeoutHandler() {     // <-- 快看，我有名字了！ 
 
    console.log( "I waited 1 second!" ); }, 1000 );
```

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：



#### 立即执行函数表达式 

```javascript
var a = 2; 
 
(function foo() { 
 
    var a = 3;    
    console.log( a ); // 3 
 
})(); 
 
console.log( a ); // 2

```

由于函数被包含在一对 (  ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 (  ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 (  ) 将函数变成表 达式，第二个 (  ) 执行了这个函数。



这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式 （Immediately Invoked Function Expression）；

函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式

```javascript
(function(){ 
    .. 
}())
```



# 块级作用域

这样的代码是全局作用域的

```javascript
 var foo = true;

    if (foo) {
        var bar = foo * 2;
        console.log( bar );
    }
    console.log( bar );
```

有没有办法，让花括号里面的bar 变成块级作用域呢，仅在花括号里面有效

使用 es6 的let

```javascript
var foo = true; 
 
if (foo) {
    let bar = foo * 2;
    console.log( bar );
} 
 
console.log( bar ); // ReferenceError

```

也可以直接写

```java
{
    let bar = foo * 2;
    console.log( bar );
} 
console.log( bar ); // ReferenceError
```







